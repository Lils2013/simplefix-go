# Simple Fix

[What is FIX](#what-is-fix-api)
[Installation](#installation)
[Getting started](#getting-started)
[Generator](#generator)
[Client (Initiator)](#starting-as-client)
[Server (Acceptor)](#starting-as-server)
[Features](#features)

## What is FIX API?

[The exhaustive material of FIX API](https://www.onixs.biz/fix-dictionary.html) 

## Installation

Download SimpleFix-Go library
```sh
$ go get -u github.com/b2broker/simplefix-go
```

Install *generator* if you want to use your own scheme.
```sh
$ cd $GOPATH/src/github.com/b2broker/simplefix-go && go install ./...
```

## Generator

Generator create message structures, tag and msg type constants and methods for work with any FIX API.

You can see basic result of Generator working at fix44 directory. It is short version of FIX 4.4 generated from scheme 
located in ./source directory.

### Simple generating example

```sh
fixgen -o=./fix44 -s=./source/fix44.xml -t=./source/types.xml
```

So, now you have your library code in ./fix44 directory.

### Parameters

`-o` – output directory

`-s` – path to main XML-scheme, you can see examples in ./source directory

`-t` – path to XML file with types mapping. This file provides generator information about type casting.
FIX protocol has a lot of types, but in Go we should have small set of types for use FIX API.

According to parameters we must have two XML files for make our own library. You can use existing files or modify them 
as you want.

## Getting started

### Session Options

This is message builder, field and message tags for session pipelines. This structure will be generated by fixgen 
command very soon.

```go
// fixgen is your generated fix package

var MySessionOpts = session.SessionOpts{
	LogonBuilder:         fixgen.Logon{}.New(),
	LogoutBuilder:        fixgen.Logout{}.New(),
	RejectBuilder:        fixgen.Reject{}.New(),
	HeartbeatBuilder:     fixgen.Heartbeat{}.New(),
	TestRequestBuilder:   fixgen.TestRequest{}.New(),
	ResendRequestBuilder: fixgen.ResendRequest{}.New(),
	Tags: messages.Tags{
		MsgType:         mustConvToInt(fixgen.FieldMsgType),
		MsgSeqNum:       mustConvToInt(fixgen.FieldMsgSeqNum),
		HeartBtInt:      mustConvToInt(fixgen.FieldHeartBtInt),
		EncryptedMethod: mustConvToInt(fixgen.FieldEncryptMethod),
	},
	AllowedEncryptedMethods: map[string]struct{}{
		fixgen.EnumEncryptMethodNoneother: {},
	},
	SessionErrorCodes: messages.SessionErrorCodes{
		RequiredTagMissing: 1,
		IncorrectValue:     5,
		Other:              99,
	},
}
```

### Starting as client

*Initiator* is a FIX API client, which connect to an existing server by.

```go

// dial to server by tcp
conn, err := net.Dial("tcp", ":9091")
if err != nil {
    panic(fmt.Errorf("could not dial: %s", err))
}

ctx, cancel := context.WithCancel(context.Background())
defer cancel()

handler := simplefixgo.NewInitiatorHandler(ctx, fixgen.FieldMsgType, 10)
client := simplefixgo.NewInitiator(conn, handler, 10)

handler.OnConnect(func() bool {
    return true
})

session := flow.NewInitiatorSession(
    context.Background(),
    handler,
    MySessionOpts,
    flow.LogonSettings{
        TargetCompID:  "Server",
        SenderCompID:  "Client",
        HeartBtInt:    5,
        EncryptMethod: fixgen.EnumEncryptMethodNoneother,
        Password:      "password",
        Username:      "login",
    },
)

// subscribe to all messages for printing incoming and outgoing messages
// you can remove existing handlers by DeleteIncoming and DeleteOutgoing method
handler.HandleIncoming(simplefixgo.AllMsgTypes, func(msg []byte) {
    fmt.Println("incoming", string(bytes.Replace(msg, fix.Delimiter, []byte("|"), -1)))
})
handler.HandleOutgoing(simplefixgo.AllMsgTypes, func(msg []byte) {
    fmt.Println("outgoing", string(bytes.Replace(msg, fix.Delimiter, []byte("|"), -1)))
})

// run session
_ = session.Run()

// sending message example
// if you dont want to fill required header every time you can send messages by session
session.Send(fixgen.ResendRequest{}.New().SetFieldBeginSeqNo(2).SetFieldEndSeqNo(3))

// run serving client and 'handle' errors
panic(client.Serve())
```

### Starting as server

*Acceptor* is a listener. It accepts and handles client connections. 
According to the FIX protocol acceptor could be provider or receiver of data.
It means acceptor can send requests to the clients and read data streams of them. 

```go
listener, err := net.Listen("tcp", fmt.Sprintf(":%d", 9091))
if err != nil {
    panic(err)
}

// handler factory uses for createing handler for each new client
handlerFactory := simplefixgo.NewAcceptorHandlerFactory(fixgen.FieldMsgType, 10)

// handlerFunc will be applied for the new handlers
// it is the place where you can bind handlers to messages 
server := simplefixgo.NewAcceptor(listener, handlerFactory, func(handler simplefixgo.AcceptorHandler) {
    session := session.NewAcceptorSession(
        context.Background(),
        PseudoGenerated,
        handler,
        session.LogonSettings{
            HeartBtInt:   30,
            LogonTimeout: time.Second * 30,
            HeartBtLimits: &session.IntLimits{
                Min: 5,
                Max: 60,
            },
        },
        func(request session.LogonSettings) (err error) {
            fmt.Printf(
                "free logon for '%s' (%s)\n",
                request.Username,
                request.Password,
            )

            return nil
        })
    _ = session.Run()
    session.SetMessageStorage(memory.NewStorage(100, 100))

    handler.HandleIncoming(simplefixgo.AllMsgTypes, func(msg []byte) {
        fmt.Println("incoming", string(bytes.Replace(msg, fix.Delimiter, []byte("|"), -1)))
    })
    handler.HandleOutgoing(simplefixgo.AllMsgTypes, func(msg []byte) {
        fmt.Println("outgoing", string(bytes.Replace(msg, fix.Delimiter, []byte("|"), -1)))
    })
})

panic(fmt.Errorf("server was stopped: %s", server.ListenAndServe()))
```

## Features

- [x] Add custom fields to protocol
- [x] Add custom messages to protocol
- [ ] Add custom types to protocol
- [x] Features for session pipelines
- [x] Acceptor (server)
- [x] Initiator (client)
- [ ] Validation of incoming messages
- [x] Validation of outgoing messages
- [ ] Mock server with testing data 
- [ ] Anything you want Just with submit a new issue
